program Sets_Lab;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  System.SysUtils;

type TSet=set of AnsiChar;  //Тип-множество Ansichar (char с русскими не работает)

var Sogl, let, res:TSet;   // Мн-ва, в которых будут все русские согласные(sogl),
                           // все русские буквы (let), и мн-во, полученное в результате
                           // выполнения задания
    line:ansistring;       // Строка ansistring, поскольку string с русскими не работает
    i: integer;            // переменная для циклов (и, соответсвенно обращения к
                           // символу строки по индексу)

Procedure DelSpaces(var S_out:ansistring);  //Процедура, удаляющая лишние пробелы
var i: integer;
begin
  i:=1;
  while i<=length(s_out) do     //Двигаюсь до конца строки
  begin
    if (s_out[i]=' ') then      //Если символ пробел, то удаляю его
      Delete(s_out, i, 1)       //i не инкрементирую, потому что при удалении
                                //длина строки уменьшится на 1, соответсвенно
                                //теперь элемент с индексом i тот, который
                                //до этого был следующим
    else
      inc(i);                   //Если не пробел, то перехожу к след. символу
  end;
end;

Function CheckLine(line:ansistring):boolean;  //Процедура проверки строки
var i:integer;
begin
  Result:=True;       //Задаю результат в True, далее буду проверять
                      //различные условия для строки и, в случае расхождения,
                      //изменю результат на False
  if line<>'' then    //Проверяю, что строка не пуста, если так, иду к других условиям
  begin
    i:=1;
    //Проверяю, что строка в самом начале не содержит точку (то есть, что в ней
    //есть хоть одно слово, учитывая, что точка должна быть концом строки) или запятую,
    //а также, что точка стоит именно в конце строки, в противном случае
    //результат в False
    if (Line[1]=',') or (Line[1]='.') or (Pos('.', line)<>length(line)) then
      result:=False;
    //Далее прохожу циклом по строке до конца либо до превого элемента, который
    //не поменяет результат в False
    while (i<>length(line)) and Result do
    begin
      if not (line[i] in let) then  //Проверяю, что символ строки это русскач
                                    //буква, иначе результат в False
        Result:=False;
      inc(i);
    end;
    if not Result then
      writeln('Некорректная строка, повторите ввод');   //Если результат в False, то вывожу сообщение
                                   //что строка некорректна
  end
  else                      //Если строка оказалась пуста, вывожу сообщение об этом,
                            //а результат перевожу в False
  begin
    result:=False;
    writeln('Ваша строка пуста, повторите ввод');
  end;
end;


begin
  Sogl:=['б'..'д','ж','з','й'..'н','п'..'т', 'ф'..'щ']; //Задаю мн-во согласных
  let:=['а'.. 'я', ',','.'];  //задаю множество всех букв (русских)
  writeln('Введите строку слов русскими буквами, разделяя их запятыми, после последнего слова поставьте точку.');
  repeat
    readln(Line);         //Ввод строки
    DelSpaces(line);      //Удаление из неё пробелов
  until checkline(line);  //Проверка, удовлетворяет ли строка условию задания.
                          //Строка вводится повторно, пока не удовлетворит
  writeln(line);          //Вывожу строку
  for i := 1 to length(line) do   //Иду по строке до конца
  begin
    if line[i] in Sogl then      //Если символ строки согласная, добавляю её
                                 //в моё результирующее множество
      res:=res+[line[i]];
  end;
  if res=[] then     //Проверяю, пусто ли множество согласных,
                     //и если да, то вывожу соответсвующее сообщение
    writeln('Согласные в введённой строке отсутствуют')
  else
    for i := 0 to 255 do       //Далее ищу, какие символы попали в реузльтирующее мн-во
                               //0-255 - диапазон AnsiChar
    begin
    if AnsiChar(i) in Res then  //Если символ есть в моём множестве, вывожу его
       write(AnsiChar(i) + ' ');                  //и превожу флаг в True

    end;
  readln
end.
